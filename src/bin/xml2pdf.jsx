// import an XML file into the Legalese template.// this runs as an Adobe InDesign script.#include "/Applications/Adobe InDesign CC/Scripts/XML Rules/glue code.jsx"main();// -------------------------------------------------- mainfunction main(){  app.scriptPreferences.enableRedraw=true;   var xmlFiles = identifyXmlFiles("queryUser"); // idleMonitor | queryUser  var indtFile = identifyIndtFile("hardcoded", // hardcoded | queryUser								  "~/non-db-src/legalese/build/00 legalese template.indt");  for (var i in xmlFiles) {	var xmlFile = xmlFiles[i];	var doc = importXmlIntoTemplate(xmlFile, indtFile);	constructFormFields(doc);	exportToPDF(doc, xmlFile);  }  app.scriptPreferences.enableRedraw=true;}// -------------------------------------------------- identifyXmlFilesfunction identifyXmlFiles(mode) {  var xmlFiles;  if (mode == "idleMonitor") {	// in future, the idle task will monitor the incoming folder for XML files	return [];  }  else if (mode == "queryUser"		  || mode == undefined) {	xmlFiles = File.openDialog(	  "Choose one or more source XML files to place into the Legalese template",	  function(file) {		return (file.constructor.name == "Folder"				|| file.name.match(/\.xml$/));	  },	  true); // multiselect  }  return xmlFiles;}// -------------------------------------------------- identifyIndtFilefunction identifyIndtFile(mode, path) {  var indtFile;  if (mode == "hardcoded") {	indtFile = new File(path);	if (indtFile.exists) return indtFile else mode = "queryUser";  }   if (mode == "queryUser"	  || mode == undefined	 ) {	indtFile = File.openDialog(	  "Choose the Legalese template",	  function(file) {		return (file.constructor.name == "Folder"				|| file.name.match(/\.indt$/));	  },	  false); // multiselect  }  alert ("got indtFile " + indtFile.path + " size " + indtFile.length);  return indtFile;}// -------------------------------------------------- importXmlIntoTemplatefunction importXmlIntoTemplate(xmlFile, indtFile) {  // here goes Chapter 12 of the Indesign Scripting Guide for JavaScript  // iterate through each element. if its tag corresponds to a paragraph style (as opposed to a character style) then append a trailing newline unless the element already has one.  var doc = app.open(indtFile);  var importMaps = {};  for (var i = 0; i < doc.xmlImportMaps.length; i++) {	importMaps[doc.xmlImportMaps.item(i).markupTag.name] = doc.xmlImportMaps.item(i).mappedStyle;  }  doc.xmlElements.item(0).importXML(xmlFile);  __processRuleSet(doc.xmlElements.item(0), [new AddReturns(doc,importMaps)]);//  alert("processRuleSet completed successfully");  doc.mapXMLTagsToStyles();  return doc;}// -------------------------------------------------- AddReturnsfunction AddReturns(doc, importMaps){  this.name = "AddReturns";  this.xpath = "//*";	  this.apply = function(myElement, myRuleProcessor){//	alert("considering " + myElement.markupTag.name//		  + " myElement " + myElement.contents//		  + " whose last char = \"" + myElement.characters.item(-1).contents//		  + "\" and is mapped to style " + importMaps[myElement.markupTag.name]);//	alert("considering " + myElement.markupTag.name//		  + " myElement " + myElement.contents//		  + " paragraphstyle=" + importMaps[myElement.markupTag.name].name//		 );	if (importMaps[myElement.markupTag.name] != undefined		&& importMaps[myElement.markupTag.name].constructor.name == "ParagraphStyle"		&& importMaps[myElement.markupTag.name].name != "[Basic Paragraph]"		&& myElement.markupTag.name != "Table"		&& myElement.markupTag.name != "Cell"		&& myElement.markupTag.name != "cell"		// and there is no XMLAttribute where addnewline=false ... though maybe that could be in xpath		&& ! myElement.contents.match(/\r$/)) {//	  alert("appending newline to element " + myElement.markupTag.name + ":\r" + myElement.contents)      myElement.insertTextAsContent("\r", XMLElementPosition.ELEMENT_END);	}    return true;  }}// -------------------------------------------------- constructFormFieldsfunction constructFormFields(doc) {//  alert("constructFormFields running");  // for each signature table in the signaturs page,  // create a new textframe adjacent to the signature table, anchored,  // and set the name of the field to be something that echosign will respect --  // in other words, <sometext>_es_signer<n>_signature  doc.viewPreferences.horizontalMeasurementUnits = MeasurementUnits.points;  doc.viewPreferences.verticalMeasurementUnits = MeasurementUnits.points;  var signatureCount = 1;  __processRuleSet(doc.xmlElements.item(0), [new AddFormFields(doc, signatureCount)]);}// -------------------------------------------------- addFormFieldsfunction AddFormFields(doc, signatureCount) {  this.name = "AddFormFields";  this.xpath = "//para_1[@class='signatureblock']";  this.apply = function(el, myRuleProcessor){	app.layoutWindows.item(0).activePage = el.paragraphs.item(0).parentTextFrames[0].parentPage;	app.layoutWindows.item(0).zoom(ZoomOptions.FIT_PAGE);//	alert("located a para_1 containing a signatureblock "//		  + "on page " + el.paragraphs.item(0).parentTextFrames[0].parentPage.name);		var myInsertionPoint = el.paragraphs.item(0).insertionPoints.item(2);	var signatureField = myInsertionPoint.signatureFields.add();//	alert("created signatureFIeld = " + signatureFIeld);	var myArray = [0, 0, 55, 216];    signatureField.geometricBounds = myArray;	with(signatureField.anchoredObjectSettings){	  anchoredPosition = AnchorPosition.anchored;	  anchorPoint = AnchorPoint.topLeftAnchor;	  horizontalReferencePoint = AnchoredRelativeTo.anchorLocation;	  horizontalAlignment = HorizontalAlignment.leftAlign;	  anchorXoffset = -160;	  verticalReferencePoint = VerticallyRelativeTo.lineBaseline;	  anchorYoffset = 3;	  anchorSpaceAbove = 0;	}	// https://secure.echosign.com/doc/TextFormsTutorial.pdf	// http://bgsfin.com/Add-Ons/SmartFormsTutorial.pdf		signatureField.name = "sigs_es_signer" + signatureCount++ + "_signature";  }}// -------------------------------------------------- exportToPDFfunction exportToPDF(doc, xmlFile) {  var pdfPath = xmlFile.fsName.replace(/\.xml$/, ".pdf");  doc.exportFile(ExportFormat.interactivePDF,				 new File(pdfPath),				 false);}